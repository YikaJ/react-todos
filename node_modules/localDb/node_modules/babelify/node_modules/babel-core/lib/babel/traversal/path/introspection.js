"use strict";

exports.__esModule = true;

/**
 * Match the current node if it matches the provided `pattern`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */

exports.matchesPattern = matchesPattern;

/**
 * Check whether we have the input `key`. If the `key` references an array then we check
 * if the array has any items, otherwise we just check if it's falsy.
 */

exports.has = has;

/**
 * Opposite of `has`.
 */

exports.isnt = isnt;

/**
 * Check whether the path node `key` strict equals `value`.
 */

exports.equals = equals;

/**
 * Check the type against our stored internal type of the node. This is handy when a node has
 * been removed yet we still internally know the type and need it to calculate node replacement.
 */

exports.isNodeType = isNodeType;

/**
 * This checks whether or now we're in one of the following positions:
 *
 *   for (KEY in right);
 *   for (KEY;;);
 *
 * This is because these spots allow VariableDeclarations AND normal expressions so we need
 * to tell the path replacement that it's ok to replace this with an expression.
 */

exports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;

/**
 * Check whether the current path references a completion record
 */

exports.isCompletionRecord = isCompletionRecord;

/**
 * Check whether or not the current `key` allows either a single statement or block statement
 * so we can explode it if necessary.
 */

exports.isStatementOrBlock = isStatementOrBlock;

/**
 * Check whether this node was a part of the original AST.
 */

exports.isUser = isUser;

/**
 * Check whether this node was generated by us and not a part of the original AST.
 */

exports.isGenerated = isGenerated;

/**
 * Check if the currently assigned path references the `importName` of `moduleSource`.
 */

exports.referencesImport = referencesImport;

/**
 * Description
 */

exports.getSource = getSource;

/**
 * Description
 */

exports.willIMaybeExecutesBefore = willIMaybeExecutesBefore;
exports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _lodashCollectionIncludes = require("lodash/collection/includes");

var _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);

var _types = require("../../types");

var t = _interopRequireWildcard(_types);

function matchesPattern(pattern, allowPartial) {
  var parts = pattern.split(".");

  // not a member expression
  if (!this.isMemberExpression()) return false;

  var search = [this.node];
  var i = 0;

  function matches(name) {
    var part = parts[i];
    return part === "*" || name === part;
  }

  while (search.length) {
    var node = search.shift();

    if (allowPartial && i === parts.length) {
      return true;
    }

    if (t.isIdentifier(node)) {
      // this part doesn't match
      if (!matches(node.name)) return false;
    } else if (t.isLiteral(node)) {
      // this part doesn't match
      if (!matches(node.value)) return false;
    } else if (t.isMemberExpression(node)) {
      if (node.computed && !t.isLiteral(node.property)) {
        // we can't deal with this
        return false;
      } else {
        search.push(node.object);
        search.push(node.property);
        continue;
      }
    } else {
      // we can't deal with this
      return false;
    }

    // too many parts
    if (++i > parts.length) {
      return false;
    }
  }

  return true;
}

function has(key) {
  var val = this.node[key];
  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

/**
 * Alias of `has`.
 */

var is = has;exports.is = is;

function isnt(key) {
  return !this.has(key);
}

function equals(key, value) {
  return this.node[key] === value;
}

function isNodeType(type) {
  return t.isType(this.type, type);
}

function canHaveVariableDeclarationOrExpression() {
  return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
}

function isCompletionRecord(allowInsideFunction) {
  var path = this;
  var first = true;

  do {
    var container = path.container;

    // we're in a function so can't be a completion record
    if (path.isFunction() && !first) {
      return !!allowInsideFunction;
    }

    first = false;

    // check to see if we're the last item in the container and if we are
    // we're a completion record!
    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

function isStatementOrBlock() {
  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {
    return false;
  } else {
    return (0, _lodashCollectionIncludes2["default"])(t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

function isUser() {
  return this.node && !!this.node.loc;
}

function isGenerated() {
  return !this.isUser();
}

function referencesImport(moduleSource, importName) {
  if (!this.isReferencedIdentifier()) return false;

  var binding = this.scope.getBinding(this.node.name);
  if (!binding || binding.kind !== "module") return false;

  var path = binding.path;
  if (!path.isImportDeclaration()) return false;

  // check moduleSource
  if (path.node.source.value === moduleSource) {
    if (!importName) return true;
  } else {
    return false;
  }

  var _arr = path.node.specifiers;
  for (var _i = 0; _i < _arr.length; _i++) {
    var specifier = _arr[_i];
    if (t.isSpecifierDefault(specifier) && importName === "default") {
      return true;
    }

    if (t.isImportNamespaceSpecifier(specifier) && importName === "*") {
      return true;
    }

    if (t.isImportSpecifier(specifier) && specifier.imported.name === importName) {
      return true;
    }
  }

  return false;
}

function getSource() {
  var node = this.node;
  if (node.end) {
    return this.hub.file.code.slice(node.start, node.end);
  } else {
    return "";
  }
}

function willIMaybeExecutesBefore(target) {
  return this._guessExecutionStatusRelativeTo(target) !== "after";
}

function _guessExecutionStatusRelativeTo(target) {
  var self = this.getStatementParent();
  target = target.getStatementParent();

  var targetFuncParent = target.scope.getFunctionParent();
  var selfFuncParent = self.scope.getFunctionParent();
  if (targetFuncParent !== selfFuncParent) {
    return "function";
  }

  do {
    if (target.container === self.container) {
      return target.key > self.key ? "before" : "after";
    }
  } while (self = self.parentPath);

  return "before";
}